<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Point & Figure Chart - Ultimate</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 100%;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .controls {
            padding: 15px;
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1;
            min-width: 120px;
        }

        .control-group label {
            font-size: 12px;
            color: #495057;
            font-weight: 600;
        }

        .control-group input,
        .control-group select {
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s;
        }

        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px;
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            user-select: none;
        }

        .checkbox-group:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            margin: 0;
        }

        .checkbox-group label {
            font-size: 13px;
            color: #495057;
            font-weight: 600;
            cursor: pointer;
            margin: 0;
        }

        .checkbox-group.active {
            border-color: #667eea;
            background: #e7eaff;
        }

        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: auto;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #ced4da;
            cursor: not-allowed;
            transform: none;
        }

        .chart-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 300px);
            min-height: 400px;
            overflow: hidden;
            background: #1e222d;
            touch-action: none;
            cursor: grab;
        }

        .chart-container:active {
            cursor: grabbing;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            padding: 0;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .info-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(30, 34, 45, 0.95);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            font-size: 12px;
            z-index: 10;
        }

        .info-panel div {
            margin: 3px 0;
        }

        .info-panel strong {
            color: #667eea;
        }

        .info-panel .realtime {
            color: #28a745;
        }

        .info-panel .auto-scroll {
            color: #ffc107;
        }

        .status {
            padding: 15px;
            margin: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 20px;
            }

            .controls {
                padding: 10px;
            }

            .control-group {
                min-width: 100px;
            }

            button {
                padding: 10px 20px;
                font-size: 13px;
            }

            .chart-container {
                height: calc(100vh - 280px);
            }

            .info-panel {
                font-size: 10px;
                padding: 8px 12px;
            }

            .checkbox-group {
                padding: 8px;
            }

            .checkbox-group label {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä Point & Figure Chart</h1>
            <p>Pan & Zoom | Price Axis | Real-time | MT5 | Auto-Scroll</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Symbol</label>
                <input type="text" id="symbol" value="EURUSD" placeholder="EURUSD">
            </div>
            <div class="control-group">
                <label>Timeframe</label>
                <select id="timeframe">
                    <option value="M1">M1</option>
                    <option value="M5">M5</option>
                    <option value="M15" selected>M15</option>
                    <option value="M30">M30</option>
                    <option value="H1">H1</option>
                    <option value="H4">H4</option>
                    <option value="D1">D1</option>
                </select>
            </div>
            <div class="control-group">
                <label>Box Size</label>
                <input type="number" id="boxSize" value="10" min="0.1" step="0.1">
            </div>
            <div class="control-group">
                <label>Reversal</label>
                <input type="number" id="reversal" value="3" min="1" step="1">
            </div>
            <div class="control-group">
                <label>Bars</label>
                <input type="number" id="bars" value="500" min="100" step="100">
            </div>
            <div class="control-group">
                <label>Auto-Refresh</label>
                <select id="autoRefresh">
                    <option value="0">Off</option>
                    <option value="5">5 sec</option>
                    <option value="10" selected>10 sec</option>
                    <option value="30">30 sec</option>
                    <option value="60">1 min</option>
                </select>
            </div>
            <div class="control-group">
                <label style="opacity: 0; user-select: none;">-</label>
                <div class="checkbox-group" id="autoScrollGroup" onclick="toggleAutoScroll()">
                    <input type="checkbox" id="autoScrollCheckbox" checked>
                    <label for="autoScrollCheckbox">üéØ Auto-Scroll</label>
                </div>
            </div>
            <button id="loadBtn" onclick="loadChart()">üìà ‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏£‡∏≤‡∏ü</button>
            <button onclick="resetView()">üîÑ Reset</button>
            <button onclick="scrollToLatest()">‚û°Ô∏è Latest</button>
        </div>

        <div id="status"></div>

        <div class="chart-container" id="chartContainer">
            <canvas id="pnfCanvas"></canvas>
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()" title="‡∏ã‡∏π‡∏°‡πÄ‡∏Ç‡πâ‡∏≤">+</button>
                <button class="zoom-btn" onclick="zoomOut()" title="‡∏ã‡∏π‡∏°‡∏≠‡∏≠‡∏Å">-</button>
                <button class="zoom-btn" onclick="resetView()" title="‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï">‚ü≤</button>
                <button class="zoom-btn" onclick="scrollToLatest()" title="‡πÑ‡∏õ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î">‚û°Ô∏è</button>
            </div>
            <div class="info-panel" id="infoPanel">
                <div><strong>Zoom:</strong> <span id="zoomLevel">100%</span></div>
                <div class="realtime">
                    <strong>Auto-Refresh:</strong> <span id="refreshStatus">Off</span>
                </div>
                <div class="auto-scroll">
                    <strong>Auto-Scroll:</strong> <span id="autoScrollStatus">On</span>
                </div>
                <div><strong>Last Update:</strong> <span id="lastUpdate">-</span></div>
                <div><strong>Next Update:</strong> <span id="nextUpdate">-</span></div>
                <div style="margin-top: 5px; border-top: 1px solid #434651; padding-top: 5px;">
                    <strong>‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:</strong>
                    <div>‚Ä¢ üì± 1 ‡∏ô‡∏¥‡πâ‡∏ß = ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô</div>
                    <div>‚Ä¢ üì± 2 ‡∏ô‡∏¥‡πâ‡∏ß = ‡∏ã‡∏π‡∏°</div>
                    <div>‚Ä¢ üñ±Ô∏è ‡∏•‡∏≤‡∏Å = ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô</div>
                    <div>‚Ä¢ üñ±Ô∏è Wheel = ‡∏ã‡∏π‡∏°</div>
                    <div>‚Ä¢ ‚û°Ô∏è = ‡πÑ‡∏õ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const API_URL = window.location.origin;
        
        // Chart data
        let chartData = null;
        let canvas, ctx;
        
        // Pan & Zoom state
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        
        // Touch handling
        let initialDistance = 0;
        let lastScale = 1;
        
        // Chart settings
        const BOX_SIZE_PX = 60;
        const PADDING_LEFT = 20;
        const PADDING_RIGHT = 100; // Space for price axis
        const PADDING_TOP = 20;
        const PADDING_BOTTOM = 20;
        const MIN_SCALE = 0.3;
        const MAX_SCALE = 5;

        // Config from server
        let serverConfig = null;

        // Auto-refresh
        let refreshInterval = null;
        let nextUpdateTime = null;

        // Auto-scroll setting
        let autoScrollEnabled = true;

        // Initialize
        window.onload = async function() {
            canvas = document.getElementById('pnfCanvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas();
            
            // Event listeners
            window.addEventListener('resize', resizeCanvas);
            
            // Mouse events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            
            // Touch events
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            
            // Setup auto-refresh change handler
            document.getElementById('autoRefresh').addEventListener('change', updateAutoRefresh);
            
            // Update checkbox group active state
            updateCheckboxGroupState();
            
            // Load config from server
            await loadConfig();
        };

        function resizeCanvas() {
            const container = document.getElementById('chartContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            if (chartData) {
                drawChart();
            }
        }

        // Toggle auto-scroll
        function toggleAutoScroll() {
            const checkbox = document.getElementById('autoScrollCheckbox');
            checkbox.checked = !checkbox.checked;
            autoScrollEnabled = checkbox.checked;
            updateCheckboxGroupState();
            document.getElementById('autoScrollStatus').textContent = autoScrollEnabled ? 'On' : 'Off';
            
            console.log('Auto-scroll:', autoScrollEnabled ? 'enabled' : 'disabled');
        }

        function updateCheckboxGroupState() {
            const group = document.getElementById('autoScrollGroup');
            const checkbox = document.getElementById('autoScrollCheckbox');
            if (checkbox.checked) {
                group.classList.add('active');
            } else {
                group.classList.remove('active');
            }
        }

        // Scroll to latest position (rightmost column)
        function scrollToLatest(smooth = false) {
            if (!chartData || !chartData.columns || chartData.columns.length === 0) {
                console.log('No chart data to scroll to');
                return;
            }

            const numColumns = chartData.columns.length;
            const chartWidth = PADDING_LEFT + numColumns * BOX_SIZE_PX + PADDING_RIGHT;
            
            // Calculate offset to show the last few columns centered
            // Show approximately 10 columns or all if less than 10
            const visibleColumns = Math.min(10, numColumns);
            const targetOffsetX = canvas.width - (PADDING_LEFT + (numColumns - visibleColumns / 2) * BOX_SIZE_PX) * scale;
            
            if (smooth) {
                // Smooth scroll animation
                const startOffsetX = offsetX;
                const distance = targetOffsetX - startOffsetX;
                const duration = 500; // ms
                const startTime = Date.now();
                
                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Easing function (ease-out)
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    
                    offsetX = startOffsetX + distance * easeOut;
                    drawChart();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                }
                
                animate();
            } else {
                // Instant scroll
                offsetX = targetOffsetX;
                drawChart();
            }
            
            console.log(`Scrolled to latest (column ${numColumns})`);
        }

        // Load configuration from server
        async function loadConfig() {
            try {
                showStatus('‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î config...', 'info');
                
                const response = await fetch(`${API_URL}/api/config`);
                if (!response.ok) {
                    throw new Error('Failed to load config');
                }
                
                serverConfig = await response.json();
                console.log('‚úÖ Config loaded:', serverConfig);
                
                // Populate form with config values
                if (serverConfig.chart) {
                    document.getElementById('symbol').value = serverConfig.chart.symbol || 'EURUSD';
                    document.getElementById('timeframe').value = serverConfig.chart.timeframe || 'M15';
                    document.getElementById('bars').value = serverConfig.chart.bars || 500;
                }
                
                if (serverConfig.pnf) {
                    document.getElementById('boxSize').value = serverConfig.pnf.box_size || 10;
                    document.getElementById('reversal').value = serverConfig.pnf.reversal_amount || 3;
                }
                
                showStatus('‚úÖ Config ‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', 'success');
                
                // Auto-connect if enabled
                if (serverConfig.mt5 && serverConfig.mt5.auto_connect) {
                    await autoConnect();
                } else {
                    showStatus('‚úÖ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô! ‡∏Å‡∏î "‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏£‡∏≤‡∏ü" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô', 'success');
                }
                
            } catch (error) {
                console.error('‚ö†Ô∏è Error loading config:', error);
                showStatus('‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î config ‡πÑ‡∏î‡πâ - ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô', 'info');
            }
        }

        // Auto-connect to MT5
        async function autoConnect() {
            try {
                showStatus('‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5...', 'info');
                
                const connectData = {
                    login: serverConfig.mt5.login,
                    password: "from_config",
                    server: serverConfig.mt5.server,
                    path: serverConfig.mt5.path || null
                };
                
                const response = await fetch(`${API_URL}/api/connect`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(connectData)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Connection failed');
                }
                
                const result = await response.json();
                console.log('‚úÖ MT5 connected:', result);
                
                showStatus(`‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5 ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! Account: ${result.account.login}`, 'success');
                
                // Auto-load chart if enabled
                if (serverConfig.chart && serverConfig.chart.auto_load) {
                    setTimeout(() => {
                        loadChart();
                    }, 1000);
                }
                
            } catch (error) {
                console.error('‚ùå Auto-connect failed:', error);
                showStatus('‚ùå ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5 ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: ' + error.message, 'error');
            }
        }

        // Load chart data
        async function loadChart(silent = false) {
            const symbol = document.getElementById('symbol').value.trim();
            const timeframe = document.getElementById('timeframe').value;
            const boxSize = parseFloat(document.getElementById('boxSize').value);
            const reversal = parseInt(document.getElementById('reversal').value);
            const bars = parseInt(document.getElementById('bars').value);
            
            if (!symbol) {
                showStatus('‚ùå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å Symbol', 'error');
                return;
            }
            
            const btn = document.getElementById('loadBtn');
            if (!silent) {
                btn.disabled = true;
                btn.textContent = '‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î...';
                showStatus('‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å MT5...', 'info');
            }
            
            try {
                const requestData = {
                    symbol: symbol,
                    timeframe: timeframe,
                    bars: bars,
                    box_size: boxSize,
                    reversal_amount: reversal
                };
                
                const response = await fetch(`${API_URL}/api/chart`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestData)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î');
                }
                
                chartData = await response.json();
                console.log('‚úÖ Chart data loaded:', chartData);
                
                // Handle view position based on auto-scroll and load type
                if (autoScrollEnabled) {
                    // Auto-scroll enabled: scroll to latest position
                    scale = 1;
                    offsetY = 0;
                    scrollToLatest(silent); // This calls drawChart() internally
                } else if (silent) {
                    // Auto-scroll disabled + Auto-refresh: keep current position and zoom
                    drawChart(); // Just redraw with new data at current position
                } else {
                    // Auto-scroll disabled + Manual load: reset to start
                    resetView(); // This calls drawChart() internally
                }
                
                const priceInfo = chartData.current_bid 
                    ? ` | Bid: ${chartData.current_bid.toFixed(chartData.symbol.includes('JPY') ? 3 : 5)}`
                    : '';
                
                if (!silent) {
                    showStatus(`‚úÖ ${symbol} ‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ${chartData.columns.length} ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå${priceInfo}`, 'success');
                }
                
                updateLastUpdateTime();
                
            } catch (error) {
                showStatus('‚ùå Error: ' + error.message, 'error');
                console.error(error);
            } finally {
                if (!silent) {
                    btn.disabled = false;
                    btn.textContent = 'üìà ‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏£‡∏≤‡∏ü';
                }
            }
        }

        // Draw chart
        function drawChart() {
            if (!chartData || !chartData.columns || chartData.columns.length === 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#6c757d';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Fill background
            ctx.fillStyle = '#1e222d';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            
            // Apply transformations
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            
            const numColumns = chartData.columns.length;
            const numRows = chartData.max_box - chartData.min_box + 1;
            
            // Draw grid
            ctx.strokeStyle = '#2a2e39';
            ctx.lineWidth = 1 / scale;
            
            for (let i = 0; i <= numColumns; i++) {
                const x = PADDING_LEFT + i * BOX_SIZE_PX;
                ctx.beginPath();
                ctx.moveTo(x, PADDING_TOP);
                ctx.lineTo(x, PADDING_TOP + numRows * BOX_SIZE_PX);
                ctx.stroke();
            }
            
            for (let i = 0; i <= numRows; i++) {
                const y = PADDING_TOP + i * BOX_SIZE_PX;
                ctx.beginPath();
                ctx.moveTo(PADDING_LEFT, y);
                ctx.lineTo(PADDING_LEFT + numColumns * BOX_SIZE_PX, y);
                ctx.stroke();
            }
            
            // Draw price labels on the RIGHT (outside transformed area)
            ctx.restore();
            ctx.save();
            
            ctx.fillStyle = '#d1d4dc';
            ctx.font = `bold ${Math.max(14, 16 * scale)}px Arial`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            
            for (let i = 0; i <= numRows; i++) {
                if (i % 3 === 0) {
                    const boxNum = chartData.max_box - i;
                    const price = (boxNum * chartData.box_size).toFixed(
                        chartData.box_size < 1 ? 2 : chartData.box_size < 10 ? 1 : 0
                    );
                    const y = offsetY + (PADDING_TOP + i * BOX_SIZE_PX + BOX_SIZE_PX / 2) * scale;
                    const x = canvas.width - PADDING_RIGHT + 10;
                    
                    // Only draw if in visible area
                    if (y > 0 && y < canvas.height) {
                        ctx.fillText(price, x, y);
                    }
                }
            }
            
            ctx.restore();
            ctx.save();
            
            // Apply transformations for drawing X and O
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            
            // Draw X's and O's
            chartData.columns.forEach((column, colIndex) => {
                const x = PADDING_LEFT + colIndex * BOX_SIZE_PX;
                
                column.boxes.forEach(boxNum => {
                    const rowIndex = chartData.max_box - boxNum;
                    const y = PADDING_TOP + rowIndex * BOX_SIZE_PX;
                    
                    if (column.type === 'X') {
                        // Draw X (green/teal)
                        ctx.strokeStyle = '#26a69a';
                        ctx.lineWidth = 3 / scale;
                        ctx.beginPath();
                        ctx.moveTo(x + 10, y + 10);
                        ctx.lineTo(x + BOX_SIZE_PX - 10, y + BOX_SIZE_PX - 10);
                        ctx.moveTo(x + BOX_SIZE_PX - 10, y + 10);
                        ctx.lineTo(x + 10, y + BOX_SIZE_PX - 10);
                        ctx.stroke();
                    } else {
                        // Draw O (red)
                        ctx.strokeStyle = '#ef5350';
                        ctx.lineWidth = 3 / scale;
                        ctx.beginPath();
                        ctx.arc(
                            x + BOX_SIZE_PX / 2,
                            y + BOX_SIZE_PX / 2,
                            BOX_SIZE_PX / 2 - 10,
                            0,
                            Math.PI * 2
                        );
                        ctx.stroke();
                    }
                });
            });
            
            ctx.restore();
            updateZoomDisplay();
        }

        // Mouse events
        function handleMouseDown(e) {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        }

        function handleMouseMove(e) {
            if (!isDragging) return;
            
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            
            offsetX += dx;
            offsetY += dy;
            
            lastX = e.clientX;
            lastY = e.clientY;
            
            drawChart();
        }

        function handleMouseUp() {
            isDragging = false;
        }

        function handleWheel(e) {
            e.preventDefault();
            
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = scale * delta;
            
            if (newScale >= MIN_SCALE && newScale <= MAX_SCALE) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                offsetX = mouseX - (mouseX - offsetX) * delta;
                offsetY = mouseY - (mouseY - offsetY) * delta;
                
                scale = newScale;
                drawChart();
            }
        }

        // Touch events
        function handleTouchStart(e) {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                isDragging = true;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                isDragging = false;
                initialDistance = getDistance(e.touches[0], e.touches[1]);
                lastScale = scale;
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
            if (e.touches.length === 1 && isDragging) {
                const dx = e.touches[0].clientX - lastX;
                const dy = e.touches[0].clientY - lastY;
                
                offsetX += dx;
                offsetY += dy;
                
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
                
                drawChart();
            } else if (e.touches.length === 2) {
                const currentDistance = getDistance(e.touches[0], e.touches[1]);
                const scaleChange = currentDistance / initialDistance;
                const newScale = lastScale * scaleChange;
                
                if (newScale >= MIN_SCALE && newScale <= MAX_SCALE) {
                    const rect = canvas.getBoundingClientRect();
                    const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
                    const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
                    
                    offsetX = centerX - (centerX - offsetX) * (newScale / scale);
                    offsetY = centerY - (centerY - offsetY) * (newScale / scale);
                    
                    scale = newScale;
                    drawChart();
                }
            }
        }

        function handleTouchEnd(e) {
            if (e.touches.length === 0) {
                isDragging = false;
            } else if (e.touches.length === 1) {
                isDragging = true;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            }
        }

        function getDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Zoom controls
        function zoomIn() {
            const newScale = scale * 1.2;
            if (newScale <= MAX_SCALE) {
                scale = newScale;
                drawChart();
            }
        }

        function zoomOut() {
            const newScale = scale * 0.8;
            if (newScale >= MIN_SCALE) {
                scale = newScale;
                drawChart();
            }
        }

        function resetView() {
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            drawChart();
        }

        function updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = Math.round(scale * 100) + '%';
        }

        // Auto-refresh functionality
        function updateAutoRefresh() {
            const interval = parseInt(document.getElementById('autoRefresh').value);
            
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
                nextUpdateTime = null;
            }
            
            if (interval > 0) {
                refreshInterval = setInterval(() => {
                    loadChart(true);
                }, interval * 1000);
                
                updateCountdown(interval);
                document.getElementById('refreshStatus').textContent = `${interval}s`;
            } else {
                document.getElementById('refreshStatus').textContent = 'Off';
                document.getElementById('nextUpdate').textContent = '-';
            }
        }

        function updateCountdown(interval) {
            nextUpdateTime = Date.now() + (interval * 1000);
            
            const countdownInterval = setInterval(() => {
                if (!nextUpdateTime) {
                    clearInterval(countdownInterval);
                    return;
                }
                
                const remaining = Math.max(0, Math.ceil((nextUpdateTime - Date.now()) / 1000));
                document.getElementById('nextUpdate').textContent = `${remaining}s`;
                
                if (remaining === 0) {
                    clearInterval(countdownInterval);
                    updateCountdown(interval);
                }
            }, 100);
        }

        function updateLastUpdateTime() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('th-TH');
            document.getElementById('lastUpdate').textContent = timeStr;
        }

        // Status messages
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
            status.style.display = 'block';
        }
    </script>
</body>
</html>
